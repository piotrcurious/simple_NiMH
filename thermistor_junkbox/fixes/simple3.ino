/**
 * Estimates temperature change of a AAA NiMH cell due to internal heating and cooling effects.
 * 
 * This function calculates how a battery's temperature will change over time based on:
 * - Heat generated by current flowing through internal resistance
 * - Convective cooling to surrounding air (natural and forced)
 * - Radiative heat transfer
 * - Thermal conduction to connected components (optional)
 * 
 * @param voltageLoaded     Voltage across cell with current flowing (V)
 * @param voltageUnloaded   Voltage across cell without current (V)
 * @param current           Current through the cell (A)
 * @param internalRes       Internal resistance of cell (Ohms)
 * @param ambientTemp       Ambient temperature (°C)
 * @param cellTemp          Current cell temperature (°C)
 * @param airflowSpeed      Air speed for forced convection (m/s), 0 for natural convection
 * @param contactAreaFrac   Fraction of battery surface in contact with conductive materials (0-1)
 * @param contactThermalRes Thermal resistance of contacted material (K/W)
 * @param cellDiameter      Diameter of AAA cell (m), default 10.5mm
 * @param cellLength        Length of AAA cell (m), default 44.5mm
 * @param timeInterval      Time interval for temperature change calculation (s)
 * @param batteryCharge     Battery state of charge (0-1), affects internal resistance
 * @return                  Estimated temperature change in °C over the specified time interval
 */
float estimateBatteryTempDelta(
  float voltageLoaded, 
  float voltageUnloaded, 
  float current, 
  float internalRes,
  float ambientTemp, 
  float cellTemp,
  float airflowSpeed = 0.0,       // m/s, 0 = natural convection
  float contactAreaFrac = 0.0,    // fraction of surface in thermal contact with other components
  float contactThermalRes = 10.0, // K/W, thermal resistance of contacted materials
  float cellDiameter = 0.0105,    // AAA diameter in meters (10.5mm)
  float cellLength = 0.0445,      // AAA length in meters (44.5mm)
  float timeInterval = 1.0,       // 1 second by default
  float batteryCharge = 0.5       // 50% charged by default
) {
  // Physical constants
  const float STEFAN_BOLTZMANN = 5.67e-8;  // Stefan-Boltzmann constant (W/(m²·K⁴))
  const float EMISSIVITY = 0.9;            // Typical emissivity for battery surface
  const float AIR_THERMAL_CONDUCTIVITY = 0.026;  // W/(m·K) at room temperature
  const float AIR_KINEMATIC_VISCOSITY = 1.568e-5; // m²/s at 25°C
  const float AIR_PRANDTL_NUMBER = 0.707;  // dimensionless, for air at room temperature
  const float SPECIFIC_HEAT_CAPACITY = 1100.0;   // J/(kg·K) for NiMH (approximate)
  const float DENSITY = 3000.0;            // kg/m³ for NiMH (approximate)
  
  // Adjust internal resistance based on battery charge and temperature
  // NiMH internal resistance typically increases at low charge levels and low temperatures
  float tempFactor = 1.0 + 0.005 * (25.0 - cellTemp);  // ~0.5% change per degree from 25°C
  float chargeFactor = 1.0 + 0.5 * (1.0 - batteryCharge);  // Up to 50% higher at low charge
  float adjustedInternalRes = internalRes * tempFactor * chargeFactor;
  
  // Calculate battery dimensions and properties
  float radius = cellDiameter / 2.0;
  float surfaceArea = 2.0 * PI * radius * radius + 2.0 * PI * radius * cellLength;  // m²
  float volume = PI * radius * radius * cellLength;  // m³
  float mass = volume * DENSITY;  // kg
  float thermalCapacity = mass * SPECIFIC_HEAT_CAPACITY;  // J/K
  
  // Calculate available surface area for convection and radiation
  // (accounting for surface in contact with other components)
  float effectiveSurfaceArea = surfaceArea * (1.0 - contactAreaFrac);
  
  // Convert temperatures to Kelvin for radiation calculations
  float cellTempK = cellTemp + 273.15;
  float ambientTempK = ambientTemp + 273.15;
  
  // Calculate power generated by internal resistance (Joule heating)
  float powerFromResistance = current * current * adjustedInternalRes;
  
  // Alternative calculation using voltage drop
  float voltageDrop = voltageUnloaded - voltageLoaded;
  float powerFromVoltageDrop = current * voltageDrop;
  
  // Use the more reliable measurement if both are available
  // For very low currents, voltage drop measurement may be more accurate
  // For high currents, internal resistance calculation is usually better
  float powerGenerated = (current > 0.1) ? powerFromResistance : powerFromVoltageDrop;
  
  // Calculate heat loss through convection to air
  float convectionCoeff;
  
  if (airflowSpeed <= 0.001) {
    // Natural convection (Rayleigh-Nusselt correlation for horizontal cylinder)
    float rayleighNumber = 9.81 * (1.0/ambientTempK) * abs(cellTemp - ambientTemp) * 
                          pow(cellDiameter, 3) / (AIR_KINEMATIC_VISCOSITY * AIR_KINEMATIC_VISCOSITY) * 
                          AIR_PRANDTL_NUMBER;
    
    float nusseltNumber;
    if (rayleighNumber < 1e-4) {
      nusseltNumber = 0.4;  // Minimal convection in still air
    } else if (rayleighNumber < 1e12) {
      nusseltNumber = 0.53 * pow(rayleighNumber, 0.25);  // Empirical correlation for cylinders
    } else {
      nusseltNumber = 0.13 * pow(rayleighNumber, 0.33);  // High Rayleigh number
    }
    
    convectionCoeff = nusseltNumber * AIR_THERMAL_CONDUCTIVITY / cellDiameter;
  } else {
    // Forced convection (Reynolds-Nusselt correlation)
    float reynoldsNumber = airflowSpeed * cellDiameter / AIR_KINEMATIC_VISCOSITY;
    float nusseltNumber;
    
    if (reynoldsNumber < 4000) {
      // Laminar flow
      nusseltNumber = 0.3 + 0.62 * sqrt(reynoldsNumber) * pow(AIR_PRANDTL_NUMBER, 0.33) * 
                     pow(1 + pow(reynoldsNumber/282000, 0.625), 0.8);
    } else {
      // Turbulent flow
      nusseltNumber = 0.024 * pow(reynoldsNumber, 0.8) * pow(AIR_PRANDTL_NUMBER, 0.33);
    }
    
    convectionCoeff = nusseltNumber * AIR_THERMAL_CONDUCTIVITY / cellDiameter;
  }
  
  float convectionLoss = convectionCoeff * effectiveSurfaceArea * (cellTemp - ambientTemp);
  
  // Calculate heat loss through radiation
  float radiationLoss = EMISSIVITY * STEFAN_BOLTZMANN * effectiveSurfaceArea * 
                       (pow(cellTempK, 4) - pow(ambientTempK, 4));
  
  // Calculate heat loss through conduction to contacted materials
  float conductionLoss = 0.0;
  if (contactAreaFrac > 0.0) {
    conductionLoss = (cellTemp - ambientTemp) / contactThermalRes;
  }
  
  // Calculate net heat flow (W)
  float netHeatFlow = powerGenerated - convectionLoss - radiationLoss - conductionLoss;
  
  // Calculate temperature change over the specified time interval (°C)
  float tempChange = (netHeatFlow * timeInterval) / thermalCapacity;
  
  // Warning indicators as return code modifiers
  // To use: check if abs(tempChange) > 100 to detect unrealistic values
  if (!isfinite(tempChange) || abs(tempChange) > 100.0) {
    // Something went wrong with the calculation, cap at a reasonable value
    tempChange = (tempChange > 0) ? 5.0 : -5.0;
  }
  
  return tempChange;
}

/**
 * Helper function to predict battery temperature over time
 * 
 * @param initialTemp       Initial cell temperature (°C)
 * @param ambientTemp       Ambient temperature (°C)
 * @param current           Constant current through cell (A)
 * @param internalRes       Internal resistance (Ohms)
 * @param duration          Total simulation duration (seconds)
 * @param voltageUnloaded   Open circuit voltage (V)
 * @param timestep          Simulation timestep (seconds)
 * @return                  Final predicted temperature (°C)
 */
float predictBatteryTemp(
  float initialTemp,
  float ambientTemp,
  float current,
  float internalRes,
  float duration,
  float voltageUnloaded,
  float timestep = 1.0
) {
  float cellTemp = initialTemp;
  float timeElapsed = 0;
  float loadedVoltage = voltageUnloaded - (current * internalRes); // Simplified initial estimate
  
  while (timeElapsed < duration) {
    // Update voltage based on temperature and discharge state
    // This is a simplified model - real batteries have complex discharge curves
    float remainingFraction = 1.0 - (timeElapsed / (3600.0 * 0.8)); // Assuming 0.8Ah capacity
    remainingFraction = constrain(remainingFraction, 0.0, 1.0);
    
    // NiMH voltage drops as discharge progresses
    float adjustedVoltage = voltageUnloaded * (0.9 + 0.1 * remainingFraction);
    loadedVoltage = adjustedVoltage - (current * internalRes);
    
    // Calculate temperature change
    float deltaT = estimateBatteryTempDelta(
      loadedVoltage,
      adjustedVoltage,
      current,
      internalRes,
      ambientTemp,
      cellTemp,
      0.0,  // No forced airflow
      0.1,  // 10% contact with other components
      10.0, // Thermal resistance
      0.0105, // AAA diameter
      0.0445, // AAA length
      timestep,
      remainingFraction // Battery charge state
    );
    
    // Update temperature
    cellTemp += deltaT;
    timeElapsed += timestep;
    
    // Safety check to avoid runaway calculations
    if (cellTemp > 80.0) {
      // Temperature too high, battery would likely fail or safety systems activate
      return 80.0;
    }
  }
  
  return cellTemp;
}

/**
 * Simple function to estimate AAA NiMH battery runtime at given current
 * 
 * @param current        Discharge current (A)
 * @param capacity       Battery capacity (mAh), default 800mAh for AAA NiMH
 * @param cutoffVoltage  Cutoff voltage (V), default 1.0V
 * @return               Estimated runtime in hours
 */
float estimateBatteryRuntime(
  float current,
  float capacity = 800.0,  // mAh
  float cutoffVoltage = 1.0 // V
) {
  // Peukert effect for NiMH (capacity reduction at high discharge rates)
  float peukertCoefficient = 1.1;  // NiMH has a relatively low Peukert coefficient
  float effectiveCapacity = capacity * pow(0.2 / current, peukertCoefficient - 1.0);
  
  // Cap the effective capacity to realistic values
  effectiveCapacity = constrain(effectiveCapacity, 0.7 * capacity, 1.2 * capacity);
  
  // Convert mAh to Ah for calculation
  float runtime = effectiveCapacity / (current * 1000.0);
  
  return runtime;
}
