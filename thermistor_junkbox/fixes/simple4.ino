/**
 * Estimates temperature change of a AAA NiMH cell due to internal heating and cooling effects.
 * 
 * This function calculates how a battery's temperature will change over time based on:
 * - Heat generated by current flowing through internal resistance (I²R losses)
 * - Heat generated by electrochemical reactions (separate from I²R losses)
 * - Convective cooling to surrounding air (natural and forced)
 * - Radiative heat transfer
 * - Thermal conduction to connected components (optional)
 * 
 * @param voltageLoaded     Voltage across cell with current flowing (V)
 * @param voltageUnloaded   Voltage across cell without current (V)
 * @param current           Current through the cell (A)
 * @param internalRes       Internal resistance of cell (Ohms)
 * @param ambientTemp       Ambient temperature (°C)
 * @param cellTemp          Current cell temperature (°C)
 * @param airflowSpeed      Air speed for forced convection (m/s), 0 for natural convection
 * @param contactAreaFrac   Fraction of battery surface in contact with conductive materials (0-1)
 * @param contactThermalRes Thermal resistance of contacted material (K/W)
 * @param cellDiameter      Diameter of AAA cell (m), default 10.5mm
 * @param cellLength        Length of AAA cell (m), default 44.5mm
 * @param timeInterval      Time interval for temperature change calculation (s)
 * @return                  Estimated temperature change in °C over the specified time interval
 */
float estimateBatteryTempDelta(
  float voltageLoaded, 
  float voltageUnloaded, 
  float current, 
  float internalRes,
  float ambientTemp, 
  float cellTemp,
  float airflowSpeed = 0.0,       // m/s, 0 = natural convection
  float contactAreaFrac = 0.0,    // fraction of surface in thermal contact with other components
  float contactThermalRes = 10.0, // K/W, thermal resistance of contacted materials
  float cellDiameter = 0.0105,    // AAA diameter in meters (10.5mm)
  float cellLength = 0.0445,      // AAA length in meters (44.5mm)
  float timeInterval = 1.0        // 1 second by default
) {
  // Physical constants
  const float STEFAN_BOLTZMANN = 5.67e-8;  // Stefan-Boltzmann constant (W/(m²·K⁴))
  const float EMISSIVITY = 0.9;            // Typical emissivity for battery surface
  const float AIR_THERMAL_CONDUCTIVITY = 0.026;  // W/(m·K) at room temperature
  const float AIR_KINEMATIC_VISCOSITY = 1.568e-5; // m²/s at 25°C
  const float AIR_PRANDTL_NUMBER = 0.707;  // dimensionless, for air at room temperature
  const float SPECIFIC_HEAT_CAPACITY = 1100.0;   // J/(kg·K) for NiMH (approximate)
  const float DENSITY = 3000.0;            // kg/m³ for NiMH (approximate)
  
  // Infer state of charge from unloaded voltage
  // NiMH voltage curve is relatively flat but drops at low and high SOC
  // Typical NiMH values: 1.0V (empty), 1.2V (nominal), 1.4V (full)
  float stateOfCharge = 0.0;
  if (voltageUnloaded <= 1.0) {
    stateOfCharge = 0.0;  // Empty
  } else if (voltageUnloaded >= 1.45) {
    stateOfCharge = 1.0;  // Full/overcharged
  } else if (voltageUnloaded <= 1.1) {
    // Low charge region (0-20%)
    stateOfCharge = (voltageUnloaded - 1.0) / 0.1 * 0.2;
  } else if (voltageUnloaded >= 1.35) {
    // High charge region (80-100%)
    stateOfCharge = 0.8 + (voltageUnloaded - 1.35) / 0.1 * 0.2;
  } else {
    // Mid charge region (20-80%) - flatter voltage curve
    stateOfCharge = 0.2 + (voltageUnloaded - 1.1) / 0.25 * 0.6;
  }
  
  // Adjust internal resistance based on battery charge and temperature
  // NiMH internal resistance typically increases at low charge levels and low temperatures
  float tempFactor = 1.0 + 0.005 * (25.0 - cellTemp);  // ~0.5% change per degree from 25°C
  float chargeFactor = 1.0;
  if (stateOfCharge < 0.2) {
    // Resistance increases significantly at low charge
    chargeFactor = 1.0 + 2.0 * (0.2 - stateOfCharge);
  } else if (stateOfCharge > 0.9) {
    // Resistance also increases slightly at very high charge
    chargeFactor = 1.0 + 0.5 * (stateOfCharge - 0.9) * 10.0;
  }
  
  float adjustedInternalRes = internalRes * tempFactor * chargeFactor;
  
  // Calculate battery dimensions and properties
  float radius = cellDiameter / 2.0;
  float surfaceArea = 2.0 * PI * radius * radius + 2.0 * PI * radius * cellLength;  // m²
  float volume = PI * radius * radius * cellLength;  // m³
  float mass = volume * DENSITY;  // kg
  float thermalCapacity = mass * SPECIFIC_HEAT_CAPACITY;  // J/K
  
  // Calculate available surface area for convection and radiation
  // (accounting for surface in contact with other components)
  float effectiveSurfaceArea = surfaceArea * (1.0 - contactAreaFrac);
  
  // Convert temperatures to Kelvin for radiation calculations
  float cellTempK = cellTemp + 273.15;
  float ambientTempK = ambientTemp + 273.15;
  
  // Calculate heat generated by internal resistance (I²R losses)
  float powerFromResistance = current * current * adjustedInternalRes;
  
  // Calculate heat from voltage drop (includes both I²R and electrochemical reactions)
  float totalVoltageDrop = voltageUnloaded - voltageLoaded;
  float totalPowerFromDrop = current * totalVoltageDrop;
  
  // Calculate electrochemical reaction heating (separate from I²R)
  // This includes electrolyte recombination, chemical side-reactions, etc.
  float electrochemicalHeating = totalPowerFromDrop - powerFromResistance;
  
  // Adjustment for charging vs discharging electrochemical heating
  // During charging, endothermic reactions can partially offset heating
  if (current < 0) {  // Negative current = charging
    float chargingFactor = 0.7 + 0.3 * stateOfCharge;  // More endothermic at high SOC
    electrochemicalHeating *= chargingFactor;
  } else {  // Discharging
    float dischargingFactor = 0.8 + 0.2 * (1.0 - stateOfCharge);  // More exothermic at low SOC
    electrochemicalHeating *= dischargingFactor;
  }
  
  // Total heat generation (W)
  float powerGenerated = powerFromResistance + electrochemicalHeating;
  
  // Calculate heat loss through convection to air
  float convectionCoeff;
  
  if (airflowSpeed <= 0.001) {
    // Natural convection (Rayleigh-Nusselt correlation for horizontal cylinder)
    float rayleighNumber = 9.81 * (1.0/ambientTempK) * abs(cellTemp - ambientTemp) * 
                          pow(cellDiameter, 3) / (AIR_KINEMATIC_VISCOSITY * AIR_KINEMATIC_VISCOSITY) * 
                          AIR_PRANDTL_NUMBER;
    
    float nusseltNumber;
    if (rayleighNumber < 1e-4) {
      nusseltNumber = 0.4;  // Minimal convection in still air
    } else if (rayleighNumber < 1e12) {
      nusseltNumber = 0.53 * pow(rayleighNumber, 0.25);  // Empirical correlation for cylinders
    } else {
      nusseltNumber = 0.13 * pow(rayleighNumber, 0.33);  // High Rayleigh number
    }
    
    convectionCoeff = nusseltNumber * AIR_THERMAL_CONDUCTIVITY / cellDiameter;
  } else {
    // Forced convection (Reynolds-Nusselt correlation)
    float reynoldsNumber = airflowSpeed * cellDiameter / AIR_KINEMATIC_VISCOSITY;
    float nusseltNumber;
    
    if (reynoldsNumber < 4000) {
      // Laminar flow
      nusseltNumber = 0.3 + 0.62 * sqrt(reynoldsNumber) * pow(AIR_PRANDTL_NUMBER, 0.33) * 
                     pow(1 + pow(reynoldsNumber/282000, 0.625), 0.8);
    } else {
      // Turbulent flow
      nusseltNumber = 0.024 * pow(reynoldsNumber, 0.8) * pow(AIR_PRANDTL_NUMBER, 0.33);
    }
    
    convectionCoeff = nusseltNumber * AIR_THERMAL_CONDUCTIVITY / cellDiameter;
  }
  
  float convectionLoss = convectionCoeff * effectiveSurfaceArea * (cellTemp - ambientTemp);
  
  // Calculate heat loss through radiation
  float radiationLoss = EMISSIVITY * STEFAN_BOLTZMANN * effectiveSurfaceArea * 
                       (pow(cellTempK, 4) - pow(ambientTempK, 4));
  
  // Calculate heat loss through conduction to contacted materials
  float conductionLoss = 0.0;
  if (contactAreaFrac > 0.0) {
    conductionLoss = (cellTemp - ambientTemp) / contactThermalRes;
  }
  
  // Calculate net heat flow (W)
  float netHeatFlow = powerGenerated - convectionLoss - radiationLoss - conductionLoss;
  
  // Calculate temperature change over the specified time interval (°C)
  float tempChange = (netHeatFlow * timeInterval) / thermalCapacity;
  
  // Warning indicators as return code modifiers
  // To use: check if abs(tempChange) > 100 to detect unrealistic values
  if (!isfinite(tempChange) || abs(tempChange) > 100.0) {
    // Something went wrong with the calculation, cap at a reasonable value
    tempChange = (tempChange > 0) ? 5.0 : -5.0;
  }
  
  return tempChange;
}

/**
 * Returns detailed battery heating components for analysis
 * 
 * @param voltageLoaded     Voltage across cell with current flowing (V)
 * @param voltageUnloaded   Voltage across cell without current (V)
 * @param current           Current through the cell (A)
 * @param internalRes       Internal resistance of cell (Ohms)
 * @param ambientTemp       Ambient temperature (°C)
 * @param cellTemp          Current cell temperature (°C)
 * @return                  struct containing heating components in Watts
 */
struct BatteryHeatingComponents {
  float resistiveHeating;      // I²R heating (W)
  float electrochemicalHeating; // Chemical reaction heating (W)
  float convectionCooling;     // Convective heat loss (W)
  float radiationCooling;      // Radiative heat loss (W)
  float conductionCooling;     // Conductive heat loss (W)
  float netHeating;            // Total net heating (W)
  float stateOfCharge;         // Estimated battery SOC (0-1)
  float tempChangeRate;        // Rate of temperature change (°C/s)
};

BatteryHeatingComponents analyzeBatteryHeating(
  float voltageLoaded, 
  float voltageUnloaded, 
  float current, 
  float internalRes,
  float ambientTemp, 
  float cellTemp,
  float airflowSpeed = 0.0,
  float contactAreaFrac = 0.0,
  float contactThermalRes = 10.0
) {
  // Physical constants
  const float STEFAN_BOLTZMANN = 5.67e-8;
  const float EMISSIVITY = 0.9;
  const float AIR_THERMAL_CONDUCTIVITY = 0.026;
  const float AIR_KINEMATIC_VISCOSITY = 1.568e-5;
  const float AIR_PRANDTL_NUMBER = 0.707;
  const float SPECIFIC_HEAT_CAPACITY = 1100.0;
  const float DENSITY = 3000.0;
  
  // Create result structure
  BatteryHeatingComponents result;
  
  // Calculate battery dimensions
  float cellDiameter = 0.0105;  // AAA diameter in meters
  float cellLength = 0.0445;    // AAA length in meters
  float radius = cellDiameter / 2.0;
  float surfaceArea = 2.0 * PI * radius * radius + 2.0 * PI * radius * cellLength;
  float volume = PI * radius * radius * cellLength;
  float mass = volume * DENSITY;
  float thermalCapacity = mass * SPECIFIC_HEAT_CAPACITY;
  float effectiveSurfaceArea = surfaceArea * (1.0 - contactAreaFrac);
  
  // Infer state of charge from unloaded voltage
  if (voltageUnloaded <= 1.0) {
    result.stateOfCharge = 0.0;
  } else if (voltageUnloaded >= 1.45) {
    result.stateOfCharge = 1.0;
  } else if (voltageUnloaded <= 1.1) {
    result.stateOfCharge = (voltageUnloaded - 1.0) / 0.1 * 0.2;
  } else if (voltageUnloaded >= 1.35) {
    result.stateOfCharge = 0.8 + (voltageUnloaded - 1.35) / 0.1 * 0.2;
  } else {
    result.stateOfCharge = 0.2 + (voltageUnloaded - 1.1) / 0.25 * 0.6;
  }
  
  // Adjust internal resistance based on SOC and temperature
  float tempFactor = 1.0 + 0.005 * (25.0 - cellTemp);
  float chargeFactor = 1.0;
  if (result.stateOfCharge < 0.2) {
    chargeFactor = 1.0 + 2.0 * (0.2 - result.stateOfCharge);
  } else if (result.stateOfCharge > 0.9) {
    chargeFactor = 1.0 + 0.5 * (result.stateOfCharge - 0.9) * 10.0;
  }
  float adjustedInternalRes = internalRes * tempFactor * chargeFactor;
  
  // Calculate heating components
  result.resistiveHeating = current * current * adjustedInternalRes;
  
  float totalVoltageDrop = voltageUnloaded - voltageLoaded;
  float totalPowerFromDrop = current * totalVoltageDrop;
  
  result.electrochemicalHeating = totalPowerFromDrop - result.resistiveHeating;
  
  // Adjust for charging vs discharging
  if (current < 0) {  // Charging
    float chargingFactor = 0.7 + 0.3 * result.stateOfCharge;
    result.electrochemicalHeating *= chargingFactor;
  } else {  // Discharging
    float dischargingFactor = 0.8 + 0.2 * (1.0 - result.stateOfCharge);
    result.electrochemicalHeating *= dischargingFactor;
  }
  
  // Calculate cooling components
  // Convert temperatures to Kelvin for radiation
  float cellTempK = cellTemp + 273.15;
  float ambientTempK = ambientTemp + 273.15;
  
  // Convection calculation
  float convectionCoeff;
  if (airflowSpeed <= 0.001) {
    // Natural convection
    float rayleighNumber = 9.81 * (1.0/ambientTempK) * abs(cellTemp - ambientTemp) * 
                          pow(cellDiameter, 3) / (AIR_KINEMATIC_VISCOSITY * AIR_KINEMATIC_VISCOSITY) * 
                          AIR_PRANDTL_NUMBER;
    
    float nusseltNumber;
    if (rayleighNumber < 1e-4) {
      nusseltNumber = 0.4;
    } else if (rayleighNumber < 1e12) {
      nusseltNumber = 0.53 * pow(rayleighNumber, 0.25);
    } else {
      nusseltNumber = 0.13 * pow(rayleighNumber, 0.33);
    }
    
    convectionCoeff = nusseltNumber * AIR_THERMAL_CONDUCTIVITY / cellDiameter;
  } else {
    // Forced convection
    float reynoldsNumber = airflowSpeed * cellDiameter / AIR_KINEMATIC_VISCOSITY;
    float nusseltNumber;
    
    if (reynoldsNumber < 4000) {
      nusseltNumber = 0.3 + 0.62 * sqrt(reynoldsNumber) * pow(AIR_PRANDTL_NUMBER, 0.33) * 
                     pow(1 + pow(reynoldsNumber/282000, 0.625), 0.8);
    } else {
      nusseltNumber = 0.024 * pow(reynoldsNumber, 0.8) * pow(AIR_PRANDTL_NUMBER, 0.33);
    }
    
    convectionCoeff = nusseltNumber * AIR_THERMAL_CONDUCTIVITY / cellDiameter;
  }
  
  result.convectionCooling = convectionCoeff * effectiveSurfaceArea * (cellTemp - ambientTemp);
  
  // Radiation cooling
  result.radiationCooling = EMISSIVITY * STEFAN_BOLTZMANN * effectiveSurfaceArea * 
                          (pow(cellTempK, 4) - pow(ambientTempK, 4));
  
  // Conduction cooling
  result.conductionCooling = 0.0;
  if (contactAreaFrac > 0.0) {
    result.conductionCooling = (cellTemp - ambientTemp) / contactThermalRes;
  }
  
  // Calculate net heating and temperature change rate
  result.netHeating = result.resistiveHeating + result.electrochemicalHeating - 
                     result.convectionCooling - result.radiationCooling - result.conductionCooling;
  
  result.tempChangeRate = result.netHeating / thermalCapacity;  // °C/s
  
  return result;
}

/**
 * Helper function to predict battery temperature over time with detailed analysis
 * 
 * @param initialTemp       Initial cell temperature (°C)
 * @param ambientTemp       Ambient temperature (°C)
 * @param current           Constant current through cell (A)
 * @param internalRes       Internal resistance (Ohms)
 * @param duration          Total simulation duration (seconds)
 * @param initialVoltage    Initial open circuit voltage (V)
 * @param timestep          Simulation timestep (seconds)
 * @param logInterval       How often to log data points (seconds)
 * @return                  Final predicted temperature (°C)
 */
float predictBatteryTemp(
  float initialTemp,
  float ambientTemp,
  float current,
  float internalRes,
  float duration,
  float initialVoltage,
  float timestep = 1.0,
  float logInterval = 60.0
) {
  float cellTemp = initialTemp;
  float timeElapsed = 0;
  float openCircuitVoltage = initialVoltage;
  float loadedVoltage = openCircuitVoltage - (current * internalRes);
  float lastLogTime = 0;
  
  // For state of charge tracking
  // Initial SOC estimation from voltage
  float stateOfCharge;
  if (openCircuitVoltage <= 1.0) {
    stateOfCharge = 0.0;
  } else if (openCircuitVoltage >= 1.45) {
    stateOfCharge = 1.0;
  } else if (openCircuitVoltage <= 1.1) {
    stateOfCharge = (openCircuitVoltage - 1.0) / 0.1 * 0.2;
  } else if (openCircuitVoltage >= 1.35) {
    stateOfCharge = 0.8 + (openCircuitVoltage - 1.35) / 0.1 * 0.2;
  } else {
    stateOfCharge = 0.2 + (openCircuitVoltage - 1.1) / 0.25 * 0.6;
  }
  
  // Estimated capacity in mAh (typical for AAA NiMH)
  float capacity = 800.0;  // mAh
  
  Serial.println(F("Time(s),Temp(C),OCV(V),LoadedV(V),SOC,ResistiveHeat(W),ElectrochemicalHeat(W),NetHeat(W)"));
  
  while (timeElapsed < duration) {
    // Update state of charge based on current
    // positive current = discharging, negative = charging
    float ampHours = (current / 3600.0) * timestep;  // Convert A*s to Ah
    float socChange = ampHours / (capacity / 1000.0);  // Convert mAh to Ah
    
    if (current > 0) {  // Discharging
      stateOfCharge -= socChange;
    } else {  // Charging
      // Account for charging efficiency (depends on SOC)
      float chargingEfficiency = 0.9;  // 90% baseline
      if (stateOfCharge > 0.8) {
        // Efficiency drops at high SOC
        chargingEfficiency = 0.9 - 0.4 * (stateOfCharge - 0.8) * 5.0;  // Down to 50% at full charge
      }
      stateOfCharge += socChange * chargingEfficiency;
    }
    
    // Keep SOC within bounds
    stateOfCharge = constrain(stateOfCharge, 0.0, 1.0);
    
    // Update voltages based on SOC
    if (stateOfCharge <= 0.2) {
      openCircuitVoltage = 1.0 + (stateOfCharge / 0.2) * 0.1;
    } else if (stateOfCharge >= 0.8) {
      openCircuitVoltage = 1.35 + ((stateOfCharge - 0.8) / 0.2) * 0.1;
    } else {
      openCircuitVoltage = 1.1 + ((stateOfCharge - 0.2) / 0.6) * 0.25;
    }
    
    // Get detailed heating analysis
    BatteryHeatingComponents heating = analyzeBatteryHeating(
      loadedVoltage,
      openCircuitVoltage,
      current,
      internalRes,
      ambientTemp,
      cellTemp,
      0.0,  // No forced airflow
      0.1,  // 10% contact with other components
      10.0  // Thermal resistance
    );
    
    // Log data at specified intervals
    if (timeElapsed - lastLogTime >= logInterval || timeElapsed == 0) {
      Serial.print(timeElapsed);
      Serial.print(F(","));
      Serial.print(cellTemp);
      Serial.print(F(","));
      Serial.print(openCircuitVoltage);
      Serial.print(F(","));
      Serial.print(loadedVoltage);
      Serial.print(F(","));
      Serial.print(heating.stateOfCharge);
      Serial.print(F(","));
      Serial.print(heating.resistiveHeating);
      Serial.print(F(","));
      Serial.print(heating.electrochemicalHeating);
      Serial.print(F(","));
      Serial.println(heating.netHeating);
      
      lastLogTime = timeElapsed;
    }
    
    // Calculate temperature change
    float deltaT = estimateBatteryTempDelta(
      loadedVoltage,
      openCircuitVoltage,
      current,
      internalRes,
      ambientTemp,
      cellTemp,
      0.0,  // No forced airflow
      0.1,  // 10% contact with other components
      10.0, // Thermal resistance
      0.0105, // AAA diameter
      0.0445, // AAA length
      timestep
    );
    
    // Update temperature and voltage
    cellTemp += deltaT;
    loadedVoltage = openCircuitVoltage - (current * internalRes);
    
    // Safety check to avoid runaway calculations
    if (cellTemp > 80.0) {
      Serial.println(F("WARNING: Battery temperature exceeds 80°C - simulation terminated"));
      return 80.0;
    }
    
    // Cut off simulation if battery depleted
    if (stateOfCharge <= 0.0 && current > 0) {
      Serial.println(F("Battery depleted - simulation terminated"));
      break;
    }
    
    // Cut off simulation if battery fully charged
    if (stateOfCharge >= 1.0 && current < 0) {
      Serial.println(F("Battery fully charged - simulation terminated"));
      break;
    }
    
    timeElapsed += timestep;
  }
  
  return cellTemp;
}

/**
 * Function to calibrate internal resistance based on measured voltage drop
 * 
 * @param voltageNoLoad     Open circuit voltage (V)
 * @param voltageUnderLoad  Voltage under test load (V)
 * @param testCurrent       Test current (A)
 * @param cellTemp          Battery temperature (°C)
 * @return                  Calibrated internal resistance (Ohms)
 *
